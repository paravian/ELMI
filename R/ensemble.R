#' Ensemble ELSIP predictions
#'
#' @importFrom caret createDataPartition predict.train
#' @importFrom checkmate assertClass assertLogical
#' @importFrom gtools permutations
#' @param ... One or more objects of class \code{\link{ELSIPTrain}} created
#'   from \code{\link[ELSIP:train.ELSIPData]{train}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the ensembled datasets. The list should contain
#'   the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @param pairwise_stack a logical value indicating whether to stack
#'   predictions from only from the training/testing set the classifiers were
#'   trained on (\code{FALSE}; default) or all pairwise combinations of
#'   training/testing imputations and classifiers (\code{TRUE}).
#' @param ensemble_single a logical value indicating whether to perform
#'   ensembling on a singly imputed dataset (i.e., when \code{imp_n} is 1).
#' @export
ensemble <- function (..., classifier, pairwise_stack = FALSE,
                      ensemble_single = FALSE) {
  models <- list(...)
  assertList(models, min.len = 1, types = c("ELSIPTrain", "multiELSIPTrain"))
  assertLogical(pairwise_stack, len = 1)
  assertLogical(ensemble_single, len = 1)

  # If there are any multiELSIPTrain objects present, extract the individual
  # ELSIPTrain objects and pass them back into the ensembler
  models <- lapply(models, function (model) {
    if (inherits(model, "multiELSIPTrain")) {
      ens_args <- model$train
      ens_args$classifier <- classifier
      ens_args$pairwise_stack <- pairwise_stack
      ens_args$ensemble_single <- ensemble_single
      return(do.call(ensemble, ens_args))
    } else {
      return(model)
    }
  })

  # Stack all of the predictions from the individual ELSIPTrain objects
  n_mod <- length(models)
  if (n_mod > 1 | (n_mod == 1 & ensemble_single)) {
    all_idx <- matrix(1:n_mod, nrow = n_mod, ncol = 2)
    if (ensemble_single) {
      all_idx <- cbind(all_idx, permutations(n_mod, 2))
      all_idx <- all_idx[order(all_idx[,2], all_idx[,1]),]
    }

    stack <- apply(all_idx, 1, function (idx) {
      model <- models[[idx[1]]]$model
      data <- models[[idx[2]]]$data$x
      as.numeric(predict.train(model, newdata = data, type = "raw"))
    })

    stack_data <- ELSIPData$new(
      x = as.data.frame(stack),
      y = models[[1]]$data$y,
      data_type = models[[1]]$data$data_type)

  } else {
    return(models[[1]])
  }

  # Train an ensembled model
  train(stack_data, classifier)
}
