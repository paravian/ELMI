#' ELSIP trainer
#'
#' Thus function trains a classification model on either a single or multiple
#' datasets, depending on whether an \code{\link{ELSIPData}} or
#' \code{\link{multiELSIPData}} object is passed, respectively. Classification
#' is handled by \code{\link[caret]{train}} from the \code{caret} package, such
#' that any supported method can be used to train an ELSIP model. A full list
#' of classification models together with possible tuning parameters is
#' available at <https://topepo.github.io/caret/train-models-by-tag.html>. Note
#' that all \code{\link{ELSIPData}} or \code{\link{multiELSIPData}} objects are
#' not permitted to have any missing values prior to training. Use
#' \code{\link[ELSIP:impute.ELSIPData]{impute}} prior to model training.
#' @importFrom caret train
#' @importFrom checkmate assertClass assertFactor assertNames assertTRUE
#' @param x An \code{\link{ELSIPData}} object, such as the output of
#'   \code{\link{classifyPrepare}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{train_control}{a list generated by
#'       \code{\link[caret]{trainControl}}.}
#'     \item{tune_grid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @param ... Ignored.
#' @return A \code{\link{ELSIPTrain}} or \code{\link{multiELSIPTrain}} object
#'   if \code{x} is a \code{\link{ELSIPData}} or
#'   \code{\link{multiELSIPData}} object respectively.
#' @rdname train
#' @method train ELSIPData
#' @export
train.ELSIPData <- function (x, classifier, ...) {
  assertClass(x, c("ELSIPData"))
  assertNames(levels(x$data_type),
              subset.of = c("Training", "Test", "Unknown"),
              must.include = c("Training", "Test"))
  assertTRUE(all(!is.na(x$x)))
  .ELSIPTrain(list(x), classifier)
}

#' @importFrom caret train
#' @importFrom checkmate assertClass assertTRUE
#' @param x An \code{\link{multiELSIPData}} object generated from
#'   \code{\link[ELSIP:impute.ELSIPData]{impute}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @param ... Ignored.
#' @method train multiELSIPData
#' @rdname train
#' @export
train.multiELSIPData <- function (x, classifier, ...) {
  assertClass(x, c("multiELSIPData"))
  for (item in x$data) {
    assertNames(levels(x$data_type),
                subset.of = c("Training", "Test", "Unknown"),
                must.include = c("Training", "Test"))
    assertTRUE(all(!is.na(item$x)))
  }
  .ELSIPTrain(x$data, classifier)
}

#' @importFrom checkmate assert checkNames checkCharacter checkDataFrame
#'   checkList checkNull
#' @importFrom caret train
.ELSIPTrain <- function (data, classifier) {
  assert(
    checkNames(names(classifier),
               must.include = c("method", "train_control", "tune_grid")),
    assert(
      checkCharacter(classifier$method, len = 1),
      checkList(classifier$method)
    ),
    checkList(classifier$train_control, min.len = 1),
    assert(
      checkNull(classifier$tune_grid),
      checkDataFrame(classifier$tune_grid)
    ),
    combine = "and"
  )

  classifier$trainControl[c("savePredictions", "returnData")] <- TRUE
  classifier$trainControl$fitBest <- FALSE

  res <- lapply(data, function (imp) {
    model <- train(
      x = imp$x[imp$data_type == "Training",],
      y = imp$y[imp$data_type == "Training"],
      method = classifier$method,
      trControl = classifier$train_control,
      tuneGrid = classifier$tune_grid,
    )
    ELSIPTrain$new(model, imp)
  })

  if (length(res) > 1) {
    res <- do.call(multiELSIPTrain$new, res)
  } else {
    res <- res[[1]]
  }
  res
}
