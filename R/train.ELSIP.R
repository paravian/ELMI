#' ELSIP trainer
#'
#' Thus function trains a classification model on either a single or multiple
#' datasets, depending on whether an \code{\link{ELSIPData}} or
#' \code{\link{multiELSIPData}} object is passed, respectively. Classification
#' is handled by \code{\link[caret]{train}} from the \code{caret} package, such
#' that any supported method can be used to train an ELSIP model. A full list
#' of classification models together with possible tuning parameters is
#' available at <https://topepo.github.io/caret/train-models-by-tag.html>. Note
#' that all \code{\link{ELSIPData}} or \code{\link{multiELSIPData}} objects are
#' not permitted to have any missing values prior to training. Use
#' \code{\link[ELSIP:impute.ELSIPData]{impute}} prior to model training.
#' @importFrom caret train
#' @importFrom checkmate assertClass assertFactor assertTRUE
#' @param data An \code{\link{ELSIPData}} object, such as the output of
#'   \code{\link{classifyPrepare}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @return A \code{\link{ELSIPTrain}} or \code{\link{multiELSIPTrain}} object
#'   if \code{data} is a \code{\link{ELSIPData}} or
#'   \code{\link{multiELSIPData}} object respectively.
#' @rdname train
#' @method train ELSIPData
#' @export
train.ELSIPData <- function (data, classifier) {
  assertClass(data, c("ELSIPData"))
  assertFactor(data$data_type, levels = c("Training", "Test", "Unknown"),
               min.levels = 2)
  assertTRUE(all(is.na(data$x)))
  .ELSIPTrain(list(data), classifier)
}

#' @importFrom caret train
#' @importFrom checkmate assertClass assertTRUE
#' @param data An \code{\link{multiELSIPData}} object generated from
#'   \code{\link[ELSIP:impute.ELSIPData]{impute}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @method train multiELSIPData
#' @rdname train
#' @export
train.multiELSIPData <- function (data, classifier) {
  assertClass(data, c("multiELSIPData"))
  for (item in data$data) {
    assertFactor(item$data_type, levels = c("Training", "Test", "Unknown"),
                 min.levels = 2)
    assertTRUE(all(is.na(item$x)))
  }
  .ELSIPTrain(data$data, classifier)
}

#' @importFrom checkmate assert checkNames checkCharacter checkDataFrame
#'   checkList checkNull
#' @importFrom caret train
.ELSIPTrain <- function (data, classifier) {
  assert(
    checkNames(names(classifier), permutation.of = c("method", "trainControl",
                                                     "tuneGrid")),
    assert(
      checkCharacter(classifier$method, len = 1),
      checkList(classifier$method)
    ),
    checkList(classifier$trainControl, min.len = 1),
    assert(
      checkNull(classifier$tuneGrid),
      checkDataFrame(classifier$tuneGrid)
    )
  )

  classifier$trainControl[c("savePredictions", "returnData")] <- TRUE
  classifier$trainControl$fitBest <- FALSE

  res <- lapply(data, function (imp) {
    model <- train(
      x = imp$x[imp$data_type == "Training",],
      y = imp$y[imp$data_type == "Training"],
      method = classifier$method,
      trControl = classifier$trainControl,
      tuneGrid = classifier$tuneGrid,
    )
    ELSIPTrain$new(model, imp)
  })

  if (length(res) > 1) {
    res <- do.call(multiELSIPTrain$new, res)
  } else {
    res <- res[[1]]
  }
  res
}
