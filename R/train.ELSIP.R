#' ELSIP trainer
#'
#' @importFrom caret train
#' @importFrom checkmate assertClass
#' @param data An \code{\link{ELSIPData}} object, such as the output of
#'   \code{\link{classifyPrepare}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @rdname train.ELSIPData
#' @method train ELSIPData
#' @export
train.ELSIPData <- function (data, classifier) {
  assertClass(data, c("ELSIPData"))
  .ELSIPTrain(list(data), classifier)
}

#' ELSIP trainer
#'
#' @importFrom caret train
#' @importFrom checkmate assertClass
#' @param data An \code{\link{multiELSIPData}} object generated from
#'   \code{\link[ELSIP]{impute}}.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed training and testing data.
#'   The list should contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @method train multiELSIPData
#' @export
train.multiELSIPData <- function (data, classifier) {
  assertClass(data, c("multiELSIPData"))
  .ELSIPTrain(data$data, classifier)
}

#' @importFrom checkmate assert checkNames checkCharacter checkDataFrame
#'   checkList checkNull
#' @importFrom caret train
.ELSIPTrain <- function (data, classifier) {
  assert(
    checkNames(names(classifier), permutation.of = c("method", "trainControl",
                                                     "tuneGrid")),
    assert(
      checkCharacter(classifier$method, len = 1),
      checkList(classifier$method)
    ),
    checkList(classifier$trainControl, min.len = 1),
    assert(
      checkNull(classifier$tuneGrid),
      checkDataFrame(classifier$tuneGrid)
    )
  )

  classifier$trainControl[c("savePredictions", "returnData")] <- TRUE
  classifier$trainControl$fitBest <- FALSE

  res <- lapply(data, function (imp) {
    model <- train(
      x = imp$x[imp$data_type == "Training",],
      y = imp$y[imp$data_type == "Training"],
      method = classifier$method,
      trControl = classifier$trainControl,
      tuneGrid = classifier$tuneGrid,
    )
    ELSIPTrain$new(model, imp)
  })

  if (length(res) > 1) {
    res <- do.call(multiELSIPTrain$new, res)
  } else {
    res <- res[[1]]
  }
  res
}
