#' Ensemble learning using stacked imputation predictions
#'
#' This is a convenience function for performing ensemble learning in
#' \code{ELSIP}. It equivalent to using, in order, \code{\link{subsample_data}}
#' (optional), \code{\link{partition_data}}, \code{\link{impute_data}},
#' \code{\link{train.ELSIPData}}, and \code{\link{ensemble}} (optional).
#' @importFrom checkmate asInt assert assertClass assertList assertLogical
#'   qassert
#' @importFrom magrittr %>%
#' @param data An \code{\link{ELSIPData}} object.
#' @param subsample a single length character indicating which
#'   subsampling to apply to the training set prior to model tuning. The
#'   default (\code{"none"}) is for no subsampling; options are \code{"up"}
#'   and \code{"down"}.
#' @param n_imp an integer indicating the number of multiple imputations to
#'   generate.
#' @param imp_method a character vector indicating the imputation method to
#'   use with \code{mice}. Can be either a single character to use for all
#'   variables, or a vector indicating the method to use for each variable.
#' @param train_prop a numeric indicating what proportion of observations will
#'   constitute the training dataset.
#' @param classifier a list defining the model and model parameters to use
#'   during classification of the multiply imputed datasets. The list should
#'   contain the following named items:
#'   \describe{
#'     \item{method}{a single length character vector indicating the
#'       classification method to use with \code{caret}.}
#'     \item{trainControl}{a list generated by
#'       \code{\link[caret:trainControl]{trainControl}}.}
#'     \item{tuneGrid}{a list defining the tuning grid to use for
#'       training the \code{caret} model.}
#'   }
#' @param pairwise_stack a logical value indicating whether to stack
#'   predictions from only from the training/testing set the classifiers were
#'   trained on (\code{FALSE}; default) or all pairwise combinations of
#'   training/testing imputations and classifiers (\code{TRUE}).
#' @param meta_classifier a list defining the model and model parameters to use
#'   during classification of the ensemble classification. Structure follows
#'   that of \code{classifier}.
#' @param ensemble_single a logical value indicating whether to perform
#'   ensembling on a singly imputed dataset (i.e., when \code{imp_n} is 1).
#' @param seed an integer value to initialise the multiple imputation.
#' @param verbose output information to the console during multiple imputation.
#' @return An \code{\link{ELSIPTrain}} object.
#' @export
ELSIP <- function (data, subsample = c("none", "up", "down"), n_imp = 10,
                   imp_method = c("mean", "median", "mice_pmm", "mice_rf", "mipca"),
                   train_prop = logical(), classifier = list(),
                   pairwise_stack = TRUE, meta_classifier = list(),
                   ensemble_single = FALSE, seed = NULL, verbose = FALSE) {
  assertClass(data, "ELSIPData")
  subsample <- match.arg(subsample)
  n_imp <- asInt(n_imp)
  qassert(n_imp, "I1[1,)")
  imp_method <- match.arg(imp_method)

  qassert(train_prop, "N1(0,1]")

  assertList(classifier, len = 3)
  if (n_imp > 1 | (n_imp == 1 & ensemble_single)) {
    assertList(meta_classifier, len = 3)
  }
  assertLogical(ensemble_single)

  assert(
    checkNull(seed),
    checkIntegerish(seed)
  )

  assertLogical(verbose, len = 1, any.missing = FALSE)
  if (!any(is.na(data$x)) & imp_method != "none") {
    stop("Dataset is already complete")
    # message("Warning: Dataset is complete, setting imputation type to none")
    # imp_method <- "none"
    # if (n_imp > 1) {
    #   stop("Cannot generate multiple imputations for complete datasets")
    # }
  }
  if (imp_method == "mean" & n_imp > 1) {
    stop("Cannot produce multiple imputations with mean value replacement")
  }
  if (ensemble_single & n_imp > 1) {
    message("Warning: ensemble_single must be FALSE if imp_n > 1")
    ensemble_single <- FALSE
  }
  if (pairwise_stack & n_imp == 1) {
    message("Warning: pairwise ensemble stacking valid only if imp_n > 1")
    pairwise_stack <- FALSE
  }

  if (subsample != "none") {
    data <- subsample_data(type = subsample, seed = seed)
  }

  res <- partition_data(data, train_prop, seed = seed) %>%
    impute_data(imp_method, n = n_imp, seed = seed) %>%
    train(classifier)

  if (n_imp > 1 | n_imp == 1 & ensemble_single) {
    res <- ensemble(res,
                    classifier = meta_classifier,
                    pairwise_stack = pairwise_stack,
                    ensemble_single = ensemble_single)
  }
  res
}
